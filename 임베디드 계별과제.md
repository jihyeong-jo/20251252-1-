# 📚 스마트 LED 원격 제어 시스템 (App Inventor, Processing, Arduino 기반 IoT)

## 1\. 프로젝트 개요 (Abstract)

본 프로젝트는 MIT App Inventor로 개발된 모바일 애플리케이션을 사용하여 로컬 네트워크 환경에서 물리적 LED의 상태를 원격 제어하고, 조도 센서 값을 실시간으로 모니터링하는 IoT 시스템 구축 보고서입니다. Processing을 중앙 게이트웨이 서버로 활용하여, 모바일 앱의 HTTP 요청을 아두이노의 시리얼 통신 명령으로 변환하고, 그 결과를 앱으로 되돌려주는 양방향 통신 구조를 구현했습니다.

| 역할 | 기술 | 사용 목적 |
| :--- | :--- | :--- |
| **클라이언트** | MIT App Inventor | Android 앱 개발, HTTP GET 요청 송수신 |
| **서버/게이트웨이** | Processing (Java/Net Library) | HTTP 서버 구축, 시리얼 통신, 데이터 파싱 |
| **하드웨어** | Arduino Uno/Nano | LED 제어, 조도 센서 값 측정 |
| **통신 환경** | Local Wi-Fi, HTTP GET, Serial (9600 bps) |

-----

## 2\. 시스템의 기대 효과 및 장점 (Expected Benefits)

1.  **실시간 상호작용 학습:** 클라이언트(앱), 서버(Processing), 하드웨어(Arduino) 간의 **3계층 통신(Three-Tier Architecture)** 흐름을 직접 구현하며 IoT 시스템의 기본 구조 및 프로토콜 변환 과정을 체계적으로 이해할 수 있습니다.
2.  **프로토콜 이해도 향상:** HTTP GET 요청 구성 및 서버에서의 요청 본문 파싱, 시리얼 데이터 변환 등 이종 프로토콜(HTTP $\leftrightarrow$ Serial) 간의 데이터 흐름을 실습합니다.
3.  **원격 제어 및 모니터링:** 로컬 네트워크 내에서 물리적인 장치(LED)의 상태를 원격으로 제어하고, 센서 값(조도)을 앱으로 실시간 피드백 받는 시스템을 구축하여 편의성을 증진합니다.

-----

## 3\. 보안 및 개선 필요 사항 (Security and Future Improvements)

현재 시스템은 학습 목적으로 적합하나, 실제 서비스 환경에 적용하기 위해 다음과 같은 보안 취약점 및 개선 사항을 해결해야 합니다.

### 3.1. 보안 취약점 (Security Issues)

1.  **평문 통신 (HTTP):** 모든 통신이 HTTP 프로토콜을 통해 이루어져 데이터가 암호화되지 않고 평문으로 전송됩니다.
      * **개선 방안:** Processing 서버를 HTTPS로 전환하거나, 통신 레이어에 TLS/SSL 암호화를 적용하여 데이터 도청을 방지해야 합니다.
2.  **접근 제어 부재:** 동일 네트워크 내의 누구라도 IP 주소와 포트만 알면 명령을 보낼 수 있습니다.
      * **개선 방안:** 앱에서 토큰을 POST 방식으로 전송하고 서버에서 이를 검증하는 **API 키 인증** 로직을 추가하여 접근 제어를 강화해야 합니다.

### 3.2. 기능 및 성능 개선 사항 (Functional Improvements)

1.  **비동기 처리 도입:** 현재 Processing 서버는 단일 요청 처리 방식(블로킹)으로 동시 요청 처리 능력이 제한적입니다.
      * **개선 방안:** Python의 Flask/Django 또는 Node.js와 같은 **비동기 서버 플랫폼**을 도입하여 동시 요청 처리 성능을 향상시켜야 합니다.
2.  **WebSockets 또는 MQTT 도입:** `Clock1.Timer`를 이용한 주기적인 GET 요청은 비효율적입니다.
      * **개선 방안:** **WebSockets** 또는 **MQTT** 프로토콜을 구현하여, 상태 변경 시 서버가 앱으로 데이터를 **푸시(Push)** 하는 방식으로 실시간성을 확보하고 네트워크 효율을 높여야 합니다.

-----

## 4\. 하드웨어 구성 및 아두이노 로직

### 4.1. 아두이노 스케치 분석

아두이노는 LED 제어 및 조도 센서 값 읽기, 그리고 \*\*자동 모드(조도 기반)\*\*와 \*\*수동 모드(앱 명령 기반, 30초 유지)\*\*를 관리합니다. 시리얼 통신을 통해 LED 상태와 조도 값(`LIGHT:XXX`)을 Processing으로 전송합니다.

### 4.2. 아두이노 스케치 (Arduino Code)

```cpp
int ledPin = 8;
int sensorPin = A0;
// (중략: 변수 선언 및 setup)

void loop() {
  int sensorValue = analogRead(sensorPin);
  // 수동 모드 타이머 체크 및 자동 모드 전환 로직
  // 자동 모드 시, 조도 값(lightThreshold = 7)에 따라 LED 제어
  // 시리얼 명령(cmd == '1' 또는 '0') 처리 시 수동 모드 전환 및 상태 전송
  Serial.print("LIGHT:");
  Serial.println(sensorValue);
  delay(200);
}
```

-----

## 5\. 게이트웨이 서버 로직 (Processing)

Processing은 포트 **12345**에서 HTTP 요청을 수신하며, 명령 파싱 및 아두이노와의 시리얼 통신을 담당합니다.

### 5.1. 핵심 파싱 로직

앱 인벤터의 GET 요청(`GET /1 HTTP/1.1...`)에서 명령어를 정확히 추출하고, 아두이노에 시리얼 전송 후 LED 상태(`"1"` 또는 `"0"`)만을 앱에 HTTP 응답으로 반환합니다.

```java
// Processing Code (App Inventor → Processing 수신 부분)
if (request.contains(" /1 ")) { // LED 켜기 명령 확인
  p.write('1'); // 아두이노로 '1' 전송
  ledState = "1";
} else if (request.contains(" /0 ")) { // LED 끄기 명령 확인
  p.write('0'); // 아두이노로 '0' 전송
  ledState = "0";
} 
// 응답: c.write("HTTP/1.1 200 OK\r\n\r\n"); c.write(ledState);
```

-----

## 6\. 모바일 애플리케이션 (App Inventor)

### 6.1. 블록 로직

| 이벤트/블록 | 동작 | 상세 |
| :--- | :--- | :--- |
| **Button1/Button2.Click** | LED 제어 명령 전송 | `join` 블록으로 URL에 `/1` 또는 `/0` 경로를 붙여 **`call Web1 .Get`** 호출 |
| **Clock1.Timer** | 주기적 상태 확인 | `join` 블록으로 기본 URL(`...:12345/`)에 GET 요청을 보내 상태 업데이트 |
| **Web1.GotText** | 상태 피드백 | `responseContent`가 `"1"`이면 "불이 켜졌습니다."를 `Label1`에 표시 |

-----

## 7\. 실행 환경 및 주의사항

1.  **IP 주소 및 포트:** 앱 인벤터에 설정된 IP 주소(예: `10.254.236.187`)와 포트(`12345`)가 Processing 서버의 현재 설정과 일치해야 합니다.
2.  **네트워크 환경:** 앱을 실행하는 스마트폰은 Processing 서버와 **동일한 Wi-Fi 네트워크**에 연결되어야 합니다.
3.  **방화벽 설정:** PC의 방화벽에서 포트 **12345번**에 대한 인바운드 접근을 반드시 허용해야 통신이 가능합니다.
4.  **COM 포트:** Processing 코드의 `Serial` 설정이 아두이노의 **정확한 COM 포트**와 일치해야 합니다.
